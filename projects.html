<html>
  <head>
    <title>Brian Fults - Project Showcase</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="nav">
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/resumes.html">Hire me!</a></li>
        <li><a href="/projects.html">Projects</a></li>
        <li><a href="extra-curricular.html">Hobbies</a></li>
      </ul>
    </div>
    <h1>Project Showcase</h1>
    <p>This page serves as a showcase for any personal or public projects about which I can share details. For work experience, check out the <a href="/resumes.html">resumes page</a></p>
    <h1>Crochet Alignment</h1>
    <p>I really dropped the ball on naming this one. This is an optimization tool, which solves the problem of: "If I want to arrange some quilt squares of different
    sizes such that the total space between them is minimized." This is annoying to solve by hand, at best, and to list all possible permutations and sort them is not
    tenable in a reasonable amount of time. So, as usual, I turned to approximation. In this solution, I wrote a simulated annealing algorithm that would seek out optimal
    neighboring states as it cools, occasionally "shaking" with some random probability. We definitely don't explore all states, but we at least get a pretty good local
    maximum that may even be the global maximum.</p>
    <p>The algorithm is basically a copy of most common annealing steps out there - the only interesting part of this implementation to me is that I implemented it
    as a lazy sequence. As such, you can create the sequence and immediately get back an "in-progress" computation. You can then examine each step along the way,
    rather than having to wait until computation is complete. I used this feature to make a visualizer in <a href="https://github.com/quil/quil">Quil.</a> The following
    gif was generated by that visualizer:</p>
    <img src="images/crochet-alignment.gif" alt="crochet alignment animation" width="300" height="400">
    <p>Links: (coming soon, currently reworking my metaheuristics library)</p>
    <h1>Futility</h1>
    <p>Futility (or fUtility) is an analysis tool for analyzing and visualizing the results of Tn-Seq data analysis. For more details about the purpose of the tool, see
    <a href="https://f-utility.hms.harvard.edu/">its homepage.</a> The tool actually went through several architectures before settling on the current system of having Javascript for viewing the results, and Java for performing the calculations. It runs as a local tool, which hosts a React-based frontend. From the browser, data sets can be uploaded and analyzed.</p>
    <p>This was a project that very much solidified in my mind that the browser isn't ready to be a one-size fits all tool deployment platform, regardless of how various tech communities feel about it. Library support for the math we needed was limited; most analysis code ran very slowly in the browser, and service workers aren't ready to do general parallel computation. Browser lockups were a serious concern when trying to perform any analysis. React was a great help in organizing the interface code, but in the end I feel this tool would be better built as a desktop application.</p>
    <p>Links:</p>
    <ul>
      <li><a href="https://f-utility.hms.harvard.edu/">Project page</a></li>
      <li><a href="https://github.com/blandflakes/futility-lib">Analysis library (Java)</a></li>
      <li><a href="https://github.com/blandflakes/futility-js">Visualizer interface (Javascript)</a></li>
      <li><a href="https://github.com/blandflakes/futility-server">Server bridge (Clojure)</a></li>
    </ul>
    <h1>Connoisseur</h1>
    <img src="/images/connoisseur.png" alt="Connoisseur Screenshot" width="628" height="400">
    <p>Connoisseur was a simple project to learn React.js, a library for building functional web applications. The goal of Connoisseur is to generate either hilarious or believe notes about a food or beverage, using text from a particular author to flavor the verbage. I used a poor man's Markov Chain to do the generation. Some notes end up hilarious, while others are just gibberish. There is also support for adding your own persona or tasting subject!</p>
    <p>Links:
    <ul>
      <li><a href="http://blandflakes.github.io/connoisseur/">Demo</a></li>
      <li><a href="https://github.com/blandflakes/connoisseur">Source</a></li>
    </ul>
    <h1>Echo Chamber (out of date) and Stopwatch</h1>
    <p>When the Echo came out, I was of course interested in writing new functionality for it. Amazon vends a Java Servlet-based SDK for writing Echo skills, but I wanted a library or framework for writing these skills in Clojure.</p>
    <p>The implementation of this project is mostly simple - I created a Ring template that generates a handler for routing requests. It does the work of parsing an HTTP JSON request into a Clojure map (specific by Schema). With this framework, I could have a simple "Hello World" application running in about 5 minutes.</p>
    <p>At this point, the upkeep of the library (in particular the schemas) would take time away from other projects, and most people seem to prefer Javascript or Python implementations, so I haven't been keeping this library in parity with the official SDK.</p>
    <p>I did create a sample skill called "stopwatch", which would simply allow you to start, stop, and reset a timer. The implementation of this isn't very interesting - the watches are saved in a Clojure atom in memory and written/read from disk on system shutdown/startup.</p>
    <p>Links:</p>
    <ul>
      <li><a href="https://github.com/blandflakes/echo-chamber">Echo Chamber</a></li>
      <li><a href="https://github.com/blandflakes/echo-chamber-template">Echo Chamber Template</a></li>
      <li><a href="https://github.com/blandflakes/echo-stopwatch">Stopwatch</a></li>
    </ul>
    <h1>Boggle</h1>
    <p>This project had two goals:</p>
    <ol>
      <li>Write an agent that will find all the valid words in a Boggle board in the fastest time possible.</li>
      <li>Generate the highest-scoring Boggle board you can.</li>
    </ol>
    <p>For the first task, I wrote a simple agent who traverses all possible combinations of letters, but who is capable of deciding "early" if a word is valid or not (i.e. if I'm partway through a word and the next letter makes the word invalid, we'll just stop). This let me prune my search space dramatically.</p>
    <p>For the second, I wrote a genetic algorithm that would start with some random samples, and mate the highest scoring boards to generate (hopefully) even higher scoring boards over many generations.</p>
    <p>Links:</p>
    <p><a href="https://github.com/blandflakes/Boggle">Source, with a more in-depth README.</a>
  </body>
</html>
